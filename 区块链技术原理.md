# 区块链技术原理

区块链是什么呢？分布式账本？去中心化数据存储方式？

我认为区块链应该是一种安全的数据架构。他不该只局限于安全货币这个狭小的领域，也不应该像现在一样几乎90%的人只关注比特币而非区块链技术本身。区块链应该有更多的应用场景。

## 目录

![image-20230922182928220](C:/Users/1649019876/AppData/Roaming/Typora/typora-user-images/image-20230922182928220.png)

![image-20230922182939867](C:/Users/1649019876/AppData/Roaming/Typora/typora-user-images/image-20230922182939867.png)



## 比特币

### 1.密码学原理

比特币是一种加密货币（crypto-currency），用到的密码学原理主要是哈希函数，利用哈希的性质：

1. **防碰撞性**（collision resistance）。

   

$$
x\neq y,  H(x)=H(y)
$$

 由于哈希的目的之一就是压缩，输入空间比输出空间大的多，一定会出现碰撞。

Collision-free：无法认为找出碰撞的y。

- 穷举（brute-force）代价太大
- md5破解

注意：collision-resistance性质无法从理论上证明



​	2.**单向性**（hiding）

从$x$可以推出$H(x)$，反向不可行
$$
x \rightarrow H(x)
$$
可用于 数字承诺 (digital commitment或digital equivalent of a sealed envelope)

预测结果不可公开，否则可能影响结果，但如果不公开又不能保证你的预测不被篡改。

而存储预测值的哈希就能保证你没有篡改你的预测。



为了扩大输入空间，还会在预测值后边拼随机数再哈希，保证不会被穷举破解：
$$
H(x||nonce)
$$
​	3.**不可预测**（puzzle friendly）

不知道哪个输入能得到一个哈希值。

挖矿：计算
$$
H(block \ header) \leq target
$$
挖矿者计算nonce满足该条件,也就是工作量证明

difficult to solve，easy to verify，计算困难验证容易

比特币所用算法：SHA256

比特币没有一个中心机构，所谓的“开户”只是生成一对公私钥。公私钥用于签名而非加密，先哈希再签名。

### 2.比特币的数据结构：hash pointers

##### 	1.**哈希指针**：

![image-20230922190229940](C:/Users/1649019876/AppData/Roaming/Typora/typora-user-images/image-20230922190229940.png)

一个数据结构可以有两个指针，一个指针是普通指针确定位置，另一个是哈希指针检查内容。

区块链用哈希指针代替了普通指针：

![image-20230922190430302](C:/Users/1649019876/AppData/Roaming/Typora/typora-user-images/image-20230922190430302.png)

genesis block是创世区块，最右边是最近区块。

每个哈希指针都是对前面一个区块的哈希。那么显然一旦修改了一个地方，就会引起哈希指针的链式改变。只要保存最后一个哈希就可以保证未被篡改。

**只要是无环的结构，hash指针都能代替普通指针**

##### 	2.Merkle Tree

默克尔树用哈希指针代替了二叉树的普通指针，每个区块取个哈希拼在一起作为父节点。只要存储根hash就能检测任何结点的篡改。

![image-20230922191012747](C:/Users/1649019876/AppData/Roaming/Typora/typora-user-images/image-20230922191012747.png)

地下的每个数据块其实是交易（transaction）

一个数据块可以分为header和body

- header里面包含了区块所有交易的根hash值，但没有交易的信息
- body保存了交易的具体信息

​	**Merkel tree 的作用**

- Merkle proof

  比特币中两种节点：全节点和轻节点，前者包括所有区块信息，后者只有header。

  一个交易者是轻节点，只知道header，他要怎么确认他的交易完成了，对方真的转帐了？

​		Merkle proof就是从交易到Merkle根的路径。

![image-20230923185933044](C:/Users/1649019876/AppData/Roaming/Typora/typora-user-images/image-20230923185933044.png)

​		轻节点向全节点发出请求，得到三个红色的哈希值。轻节点先计算黄色交易的hash，然后与红色哈希值拼接，不断向上计算，最终得到根hash，与自己的header比较就知道是否存在这一个交易。

​	问题：构造hash碰撞可以伪造交易



- proof of membership

  如果要证明哪个交易在里边，可以从根节点向下搜索，复杂度$O(log\ n)$；但是证明不在需要遍历。复杂度$O(n)$

  如何简化不存在证明？把叶节点哈希值排序，做一个排序默克尔树。

### 3.协议

如果我们把数字货币，像纸币一样一个面额加签一个私钥签名，能不能像纸币一样用？

——不行的，虽然他签了名，但里面的内容也就是面额是不用改的，甚至可以复制一份，当两份花。（double spending attack）

固然我们可以给每个电子货币打编号，并存储编号数据库，但这样做中心机构的业务压力太大了。区块链的功能就是让银行的业务让所有人一起承担。

两个问题：

1. 怎么决定货币什么时候发行、该发行多少
2. 怎么防范Double spending attack

##### 1.区块链构造

A 获得了铸币权，发行了10个比特币：

![image-20230926134456691](C:/Users/1649019876/AppData/Roaming/Typora/typora-user-images/image-20230926134456691.png)

A将比特币交易给B和C各5个，这个交易需要A的签名，要说明A的币的来源：

![image-20230926134533687](C:/Users/1649019876/AppData/Roaming/Typora/typora-user-images/image-20230926134533687.png)

整体的交易构成一个小型的区块链：

![image-20230926134703825](C:/Users/1649019876/AppData/Roaming/Typora/typora-user-images/image-20230926134703825.png)



两种哈希指针：一种把区块串起来构成链表，一个指向前面的交易，说明币的来源，防范双花攻击。

一个转账交易需要的信息：A的签名、B的地址。地址由公钥hash再做一些处理得到，证明A的签名需要A的公钥。

铸币时需要提供A公钥的哈希，而后面A做交易需要说出他的公钥，这个公钥必须和铸币时A公钥哈希对上。这样可以使发送者公开自己公钥的同时，不被其他人顶替（因为公钥是自己说出去的，其他人可以把自己的公钥公开出去假装自己是A）

##### 2.区块细节构造

实际系统中每个区块包含多个交易，分成块头块身两部分

头部包括：区块链版本信息，前块头的哈希、默克尔根哈希、挖矿的难度目标阈值、随机数

![image-20230926140908760](C:/Users/1649019876/AppData/Roaming/Typora/typora-user-images/image-20230926140908760.png)



块身包括：交易列表

![image-20230926141118233](C:/Users/1649019876/AppData/Roaming/Typora/typora-user-images/image-20230926141118233.png)



区块间通过头部哈希指针连接。

##### 3.全节点和轻节点

- 全节点（full node/ fully validating node）

保存了header和body的信息，参与区块链的构造维护、验证区块合法性。

![image-20230929134941899](C:/Users/1649019876/AppData/Roaming/Typora/typora-user-images/image-20230929134941899.png)

- 轻节点（light node）

只保存block header信息。轻节点不能独立验证交易合法性，因为它没有存储以前的交易信息。只利用区块链信息做查询。



##### 4.区块链信息如何写入

每个人的本地维护区块链进行记账，但账本的内容要取得分布式的共识。

- Distributed consensus

分布式机器维护了一个distributed hash table（键值对表）

CAP Theorem

三个性质：consistency、availability、partition tolerance

**比特币中的共识**

1. 投票法：半数以上支持则写入

   任何需要投票的方案，首先要确定投票权。比如联盟链，大公司才准入那么大多数都是好的，可以投票。但是比特币系统中创建节点是很容易的、别人不知道的，很容易受到攻击，不能投票。

   女巫攻击：攻击者产生大量账号，夺取投票控制权。

1. **比特币的投票方法：按计算力投票**

​		谁先能挖出符合式（2）的nonce，谁才有权力发布下一个区块。
$$
H(block \ header) \leq target
$$
​		其他节点接收到了他的区块需要检查该区块header条件是否符合、验证交易列表中交易合法（签名、非双花），有一不满足则放弃。

​		还有一个问题，区块根据header中的previous hash 来判断接在哪里。如果我们产生一个合法的区块但是插在区块之间，会导致事务回滚。（分叉攻击 fork attack）

​		合法的分叉情况 ：同时发布区块。临时分叉会维持一段时间，但最长链才是合法的。没及时找到下一个区块的链会被丢弃（orphan block）



##### 5.为什么要争夺记账权

- block reward

获得记账权的节点，可以允许一个特殊的交易：铸币交易。这是唯一的产生新的币的途径。前21万区块可发行50币，每21万区块减半。

每一个交易还会给它一笔手续费。



争夺记账权可以获得经济利益。

### 4.比特币的实现

##### 1.基于交易的账本

比特币是基于交易的账本，每个区块记录的是交易信息。没有记录一个账号里有多少钱。

一个全节点要维护UTXO数据结构（unspent transaction output，未花费的交易输出）UTXO维护产生输出的交易哈希，以及它在交易中是第几个输出。

- 例子：A给B和C转账，B把5个币花掉了，交易就不在UTXO里，C没花掉，就在UTXO里

![image-20230927171428960](C:/Users/1649019876/AppData/Roaming/Typora/typora-user-images/image-20230927171428960.png)

UTXO可以防范双花攻击，币在消费之前要在UTXO里。

一个区块的例子：

![image-20230927173253622](C:/Users/1649019876/AppData/Roaming/Typora/typora-user-images/image-20230927173253622.png)

一个块里有686个交易，输出4k多个币

##### 2.基于账户的账本

以太坊就是基于账户的账本，存在节点一说，所以也不需要UTXO

##### 3.挖矿过程的概率分析

每次挖矿就是计算一个nonce，可以看作一次Bernoulli trial （假设我们进行一系列的实验，这些实验之间是与统计无关的，而且每个实验仅有两种可能的结果，设所有这些实验取得两个中的任一结果的概率都是一样的。例如，当投掷一个硬币时，那么可能的结果就是头像朝上和头像朝下。在理想的情况下，如果这些实验满足所说的条件，我们就称它为“贝努利实验”）

一些独立的bernoulli trial 的序列构成Bernoulli process。Bernoulli process 具有无记忆性。 

实验的次数很多，每次成功概率很小，伯努利过程可以近似未Poisson process。整个系统的出块时间和概率密度呈指数关系：出块时间越短，挖到矿的概率就要越高。而具体到每个矿工身上就要把这个概率用算力分配。

##### 4.比特币安全性分析

假设大多数算力在诚实的矿工手里，能保证交易的安全性吗？

连续的挖出更长区块接在某个区块上，就能造成已有交易的回滚。利用这种回滚可以使已经花到电商平台的币被回滚——可见区块链的不可篡改只是概率问题。

![image-20230927181210663](C:/Users/1649019876/AppData/Roaming/Typora/typora-user-images/image-20230927181210663.png)

### 5.比特币网络

比特币协议工作在应用层，底层是P2P的网络层。

P2P网络所有节点对等，没有super node和master node。

要加入这个网络需要知道一个seed node，seed node 会告诉你它知道的节点。退出这个网络只要关掉程序不再TCP通信就行了。

比特币网络的设计目的是：**简单鲁棒，而非高效**

消息的传播是洪泛方法（flooding）、

比特币网络的邻居不考虑底层拓扑和现实地理位置。

比特币系统中每个节点维护一个等待上链的交易集合。

![image-20230927184520620](C:/Users/1649019876/AppData/Roaming/Typora/typora-user-images/image-20230927184520620.png)

节点先受收到A->B，则A->C的交易与之冲突就无效了。如果A->B包含在区块里，就把集合里的删掉。**如果A->C包含在区块里，也要删掉，否则会造成双花**。

比特币网络的通信是best effort的，有些节点该转发的不转发，不该转发的会转发。

### 6.挖矿难度和挖矿

##### 1.挖矿的难度

计算
$$
H(block \ header) \leq target
$$
挖矿者计算nonce满足该条件,也就是工作量证明

difficult to solve，easy to verify，计算困难验证容易

比特币所用算法：SHA256，取值空间是$2^{256}$

**挖矿难度**和目标阈值target呈反比
$$
difficulty=\frac{difficulty\_1\_target}{target}
$$
分子是最低挖矿难度（1）时的target，分母是当前target。

挖矿难度太小会导致**区块链频繁出现分叉**，危害系统安全，而且导致算力浪费等等问题。

##### 2.挖矿

挖矿需要发布区块，必须要全节点。如果别人延申了最长合法链，只能放弃挖矿，重新组装区块。挖矿是memory less的，停下来挖新区块概率也是一样的。

区块链的安全性由密码学和共识机制保证。

- 挖矿设备：由普通计算机CPU演进到用GPU挖矿再进化到ASIC芯片（application specific integrated circuit）制作的专用矿机。
- merge mining：新发行币挂靠在比特币上，挖比特币等于挖新币，相当于帮新币启动。
- 矿池：单个矿工个体挖矿是很难的，因为个体挖矿概率低，还要承担全节点的其他职责，要承担浪费的成本。矿池把大量矿工组织起来，给他们发布挖矿任务，矿工把挖到的nonce上交给矿主，获得区块的分红。获得分红需要按工作量分配，但这个工作量不能像挖到矿一样困难。只要把挖矿难度降低，挖出来的almost valid block虽然没用，但可以向矿主证明自身的工作量。
- 矿工无法私自提交区块，因为矿主负责组装区块，里边是矿主的收货地址。如果矿工自己发布区块，就跟自己单干没区别。

##### 3.半数算力攻击

- 分叉攻击

  只要攻击者有51%算力，他发布区块的能力就比其他所有人加起来都强，就可以强行制作最长链造成分叉。

- Boycott攻击

  只要出现目标交易，就能依仗算力强行分叉。这样别人也不愿意包含目标交易，否则别人挖出的区块也会被攻击而白费。

### 7.比特币脚本

比特币脚本是基于栈的语言，能访问的空间只有一个栈。

![image-20231010173344941](C:/Users/1649019876/AppData/Roaming/Typora/typora-user-images/image-20231010173344941.png)

输入脚本：把两个很长的数压栈

输出脚本：对应两个输出的两个单独脚本

![image-20231010173429467](C:/Users/1649019876/AppData/Roaming/Typora/typora-user-images/image-20231010173429467.png)

交易ID、hash、版本号、交易大小、交易生效时间（locktime=0立即生效，=10等10个区块后才写入）、输入、输出、交易所在区块hash、交易已有多少确认信息、交易产生时间、区块产生时间（秒）

![image-20231010173722343](C:/Users/1649019876/AppData/Roaming/Typora/typora-user-images/image-20231010173722343.png)

